{"name":"Buienradar Rain","type":"com.fibaro.multilevelSensor","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_387"},"sections":{"items":[{"components":[{"name":"label1","style":{"weight":"1.2"},"text":"Buienradar Rain ","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"label3","style":{"weight":"1.2"},"text":"Label3","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"label2","style":{"weight":"1.2"},"text":"Label2","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"label4","style":{"weight":"1.2"},"text":"Label4","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_387"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"intervalR","value":"60"},{"name":"intervalD","value":"300"},{"name":"latitude","value":"52.38"},{"name":"longitude","value":"5.27"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"-- QuickApp BUIENRADAR RAIN \n\n-- This QuickApp predicts the rain with data from the Dutch Buienradar, two hours in advance\n-- The value of this QuickApp represents the minutes until rain\n-- If there is no rain expected, the value is set to 0\n-- If it rains, the value is set to 999 and the amount of rain (mm/h) is shown\n-- Buienradar updates every 5 minutes with intervals of 5 minutes until 2 hours in advance. If rain is expected within the first predicted 5 minutes or less, the QuickApp assumes it is raining. \n-- If rain is expected or it rains, the interval for checking the Buienradar data (default without rain 300 seconds, equal to the Buienradar updates) is speed up (default 60 seconds) so the QuickApp value is updated more often\n-- With the value updated in this QuickApp, you are able to build and use your own scenes to notify, to close or open sunscreens, to close or open windows, etcetera\n\n-- Version 0.1 (15th August 2020)\n-- Initial version\n\n-- JSON data copyright: (C)opyright Buienradar / RTL. All rights reserved. \n-- JSON data terms: Deze feed mag vrij worden gebruikt onder voorwaarde van bronvermelding buienradar.nl inclusief een hyperlink naar https://www.buienradar.nl. Aan de feed kunnen door gebruikers of andere personen geen rechten worden ontleend.\n\n-- The value 000 indicates no rain (dry), the value 255 indicates heavy rain. \n-- Used formula for converting to the rain intensity in the unit millimetre per hour (mm/h): Rain intensity = 10^(value-109)/32)\n-- Example: a value of 77 is equal to a rain intensity of 0,1 mm/h.\n\n-- Variables mandatory:\n-- IntervalR = Number in seconds to update the data when rain expected or raining (must be different to IntervalD)\n-- IntervalD = Number in seconds to update the data when no rain expected, Buienradar is updated every 300 seconds\n-- Latitude = of your location (Default is the latitude of your HC3)\n-- Longitude = of your location (Default is the longitude of your HC3)\n\n\n-- Below here no changes are needed\n\n\nfunction QuickApp:onInit()\n\n  __TAG = \"BUIENRADAR_RAIN_\"..plugin.mainDeviceId\n  self:debug(\"OnInit\") \n\n  url = \"https://br-gpsgadget.azurewebsites.net/data/raintext?lat=\"\n  intervalR = tonumber(self:getVariable(\"intervalR\"))\n  intervalD = tonumber(self:getVariable(\"intervalD\"))\n  latitude = tonumber(self:getVariable(\"latitude\"))\n  longitude = tonumber(self:getVariable(\"longitude\"))\n\n  -- Check existence of the mandatory variables, if not, create them with default values\n  if intervalR == \"\" or intervalR == nil then\n    intervalR = \"60\" -- Default intervalR (rain expected or raining) is 60 seconds\n    self:setVariable(\"intervalR\", intervalR)\n    self:trace(\"Added QuickApp variable intervalR\")\n    intervalR = tonumber(intervalR)\n  end\n  if intervalD == \"\" or intervalD == nil then\n    intervalD = \"300\" -- Default intervalD (dry, no rain) is 300 seconds\n    self:setVariable(\"intervalD\", intervalD)\n    self:trace(\"Added QuickApp variable intervalD\")\n    intervalD = tonumber(intervalD)\n  end\n  if latitude == 0 or latitude == nil then \n    latitude = string.format(\"%.2f\",api.get(\"/settings/location\")[\"latitude\"]) -- Default latitude of your HC3\n    self:setVariable(\"latitude\", latitude)\n    self:trace(\"Added QuickApp variable latitude\")\n  end  \n  if longitude == 0 or longitude == nil then\n    longitude = string.format(\"%.2f\",api.get(\"/settings/location\")[\"longitude\"]) -- Default longitude of your HC3\n    self:setVariable(\"longitude\", longitude)\n    self:trace(\"Added QuickApp variable longitude\")\n  end\n  interval = intervalD\n  latitude = string.format(\"%.2f\",latitude) -- double check, to prevent 404 response\n  longitude = string.format(\"%.2f\",longitude) -- double check, to prevent 404 response\n  --self:debug(\"latitude: \", latitude)\n  --self:debug(\"longitude: \", longitude)\n\n  url = url ..latitude ..\"&lon=\" ..longitude -- Combine webaddress and location info\n\n\n  self.http = net.HTTPClient({8*1000})\n\n  self:loop(\"\")\n\nend\n\n\nfunction QuickApp:loop(text) \n\n  self.http:request(url, {\n    options={\n      headers = {Accept = \"application/json\"}, method = 'GET'}, success = function(response)\n      --self:debug(\"response status:\", response.status) \n      --self:debug(\"headers:\", response.headers[\"Content-Type\"])\n      --self:debug(\"url: \", url)\n      apiResult = response.data\n\n      -- Test settings\n      --apiResult = \"000|00:45 000|00:50 000|00:55 000|01:00 000|01:05 000|01:10 012|01:15 000|01:20 000|01:25 000|01:30 000|01:35 000|01:40 000|01:45 030|01:50 023|01:55 010|02:00 000|02:05 000|02:10 000|02:15 000|02:20 000|02:25 000|02:30 000|02:35 000|02:40\" -- Rain expected\n      --apiResult = string.gsub(apiResult,\"000\",\"077\") -- Test all rain\n      --self:debug(\"apiResult: \",apiResult) \n      --self:debug(\"Interval: \", interval)\n\n      apiResult = apiResult:gsub(\"000|\", \"\") -- Erase all non rain data\n      pos = string.find(apiResult, \"|\" ) -- Search for remaining rain data\n      --self:debug(\"pos: \", pos)\n      if pos ~= nil then -- There is rain (expected)\n        local rTime = apiResult:sub(pos+1,pos+5) -- Time expected rain\n        local rTimeHour = tonumber(rTime:sub(1,2))\n        local rTimeMinute = tonumber(rTime:sub(4,5))\n        local currentTime = os.date(\"%H:%M\")\n        local cTimeHour = tonumber(currentTime:sub(1,2))\n        local cTimeMinute = tonumber(currentTime:sub(4,5))\n        if rTimeHour < cTimeHour then -- Current time before and rain time after 24:00\n          rTimeHour = rTimeHour + 24\n        end\n        local rMinute = (rTimeHour-cTimeHour)*60+(rTimeMinute-cTimeMinute) -- Minutes until rain\n        if rMinute <= 5 then -- It is raining\n          interval = intervalR -- Speed up interval to intervalR when it rains\n          local rainIntensity = string.format(\"%.2f\",10^((apiResult:sub(pos-4,pos-1)\n-109)/32)) -- Calculate rain intensity in milimeters / hour\n          self:debug(\"It rains \" ..rainIntensity ..\" mm/h (\" ..rTime ..\")\")\n          self:updateView(\"label3\", \"text\", \"It rains \" ..rainIntensity ..\" mm/h (\" ..rTime ..\")\")\n          self:updateView(\"label4\", \"text\", \"Interval: \" ..interval)\n          self:updateProperty(\"value\", 999)\n          self:updateProperty(\"unit\", \" min\")\n          self:updateProperty(\"log\", \"Rain \" ..rainIntensity ..\" mm/h (\" ..rTime ..\")\")\n        else -- Rain is expected\n          interval = intervalR -- Speed up interval to intervalR when rain expected\n          self:debug(\"Rain expected in \", rMinute ..\" minutes at \" ..rTime)\n          self:updateView(\"label3\", \"text\", \"Rain expected in \" ..rMinute ..\" minutes at: \" ..rTime)\n          self:updateView(\"label4\", \"text\", \"Interval: \" ..interval)\n          self:updateProperty(\"value\", rMinute)\n          self:updateProperty(\"unit\", \" min\")\n          self:updateProperty(\"log\", \"Rain at \" ..rTime)\n        end\n      else -- No rain is expected\n        if interval == intervalR then\n          self:debug(\"No more rain expected\")\n        end\n        interval = intervalD -- Decrease interval to intervalD when no rain expected \n        local lastTime = apiResult:sub(apiResult:len()-6,apiResult:len())\n        self:updateView(\"label3\", \"text\", \"No rain expected until \" ..lastTime)\n        self:updateView(\"label4\", \"text\", \"Interval: \" ..interval)\n        self:updateProperty(\"value\", 0)\n        self:updateProperty(\"unit\", \"\")\n        self:updateProperty(\"log\", \"No rain until \" ..lastTime)  \n      end\n\n      -- Update View\n      self:updateView(\"label2\", \"text\", \"Latitude: \" ..latitude ..\" | \" ..\"Longitude: \" ..longitude) \n\n      --self:debug(\"--------------------- END --------------------\") \n      \n    end,\n    error = function(error)\n    self:error('error: ' .. json.encode(error))\n    self:updateProperty(\"log\", \"error: \" ..json.encode(error))\n  end\n}) \n\n  fibaro.setTimeout(interval*1000, function() -- Checks every [interval] seconds for new data\n  self:loop(text)\n  end)\n\nend\n\n"}]}